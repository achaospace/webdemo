<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>byui</title>
  <link rel="stylesheet" href="../dist/css/byui.css" />
  <style>
    body td,
    body code,
    body p {
      font-size: 16px;
    }

    .title-center {
      margin-left: 50%;
      font-size: 34px !important;
    }

    .site-h1 {
      margin-bottom: 20px;
      line-height: 60px;
      padding-bottom: 10px;
      color: #393d49;
      border-bottom: 1px solid #eee;
      font-size: 28px;
      font-weight: 300;
    }

    .byui-elem-quote {
      line-height: 22px;
      border-radius: 0 2px 2px 0;
      background-color: #f2f2f2;
      padding: 8px 16px;
      background-color: #ecf8ff;
      border-radius: 4px;
      border-left: 5px solid #50bfff;
      margin: 20px 0;
    }

    .byui-field-title {
      border-width: 1px 0 0;
      border-color: #e6e6e6;
    }

    .gray {
      color: gray;
    }

    .nav-code {
      color: #009688
    }

    .blue {
      color: red;
    }

    .nav-table {
      width: 95%;
      margin: 10px 0 0 24px;
      border: 1px solid darkgray;
      text-align: center;
    }

    .nav-table tr td.white {
      color: green;
      text-align: left
    }

    .nav-table td {
      padding: 16px 8px;
      border-right: 1px solid darkgray;
      border-bottom: 1px solid darkgray;
      text-align: left;
    }

    .nav-li a,
    .nav-table a {
      color: red;
    }

    .nav-table tr td:first-child {
      color: red;
    }

    .left {
      text-align: left;
    }

    .byui-code {
      font-size: 16px;
    }

    .byui-layout-admin .byui-header {
      border-bottom: 1px solid #dcdfe6;
      background: white;
    }

    .byui-nav-tree .byui-nav-item a:hover {
      color: #409eff
    }

    .byui-this,
    .byui-this>a {
      background: white !important;
      color: #409eff !important;
    }

    .byui-nav-itemed>a {
      color: #393d49 !important;
      font-weight: bold;
    }

    .byui-nav-tree .byui-nav-item a:hover {
      background-color: white;
      color: #409eff;
    }

    .byui-nav {
      background-color: #ffffff;
    }

    .byui-nav-tree .byui-nav-child a {
      color: black;
    }

    .byui-nav-item .byui-nav-itemed>.byui-nav-child {
      display: block;
      padding: 0;
      background-color: white;
    }

    .byui-nav-itemed>.byui-nav-child {
      display: block;
      padding: 0;
      background-color: white !important;
    }

    .byui-nav-tree .byui-nav-bar {
      background-color: #409eff;
    }

    .byui-layout-admin .byui-logo {
      color: #409eff;
    }
    .byui-nav .byui-nav-item a{
      color: black;
    }
  </style>
</head>

<body class="byui-layout-body">
  <div class="byui-layout byui-layout-admin">
    <div class="byui-header">
      <div class="byui-logo title-center">byui</div>
      <div class="byui-nav byui-layout-right">

      </div>
    </div>
    <div class="layui-code layui-box">
      <div class="layui-code layui-box-scroll">
        <!-- 左侧导航区域（可配合byui已有的垂直导航） -->
        <dd class="byui-nav byui-nav-tree" by-filter="test">
          <li class="byui-nav-item byui-nav-itemed">
            <a class="" href="javascript:;">基础说明<span class="byui-nav-more"></span></a>
            <dl class="byui-nav-child">
              <dd><a href="start.html">开始使用</a></dd>
              <dd><a href="element.html">页面元素</a></dd>
              <dd><a href="infrastructure.html">底层方法</a></dd>
              <dd><a href="modules.html">模块规范</a></dd>
            </dl>
          </li>
          <li class="byui-nav-item byui-nav-itemed">
            <a class="" href="javascript:;">布局<span class="byui-nav-more"></span></a>
            <dl class="byui-nav-child">
              <dd><a href="layout.html">栅格</a></dd>
              <dd><a href="color.html">颜色</a></dd>
              <dd><a href="icon.html">图标</a></dd>
            </dl>
          </li>
          <li class="byui-nav-item byui-nav-itemed">
            <a href="javascript:;">基本元素<span class="byui-nav-more"></span></a>
            <dl class="byui-nav-child">
              <dd><a href="button.html">按钮</a></dd>
              <dd><a href="tab.html">选项卡</a></dd>
              <dd><a href="progress.html">进度条</a></dd>
              <dd><a href="badge.html">徽章</a></dd>
              <dd><a href="anim.html">动画</a></dd>
              <dd><a href="auxiliar.html">辅助元素</a></dd>
            </dl>
          </li>
          <li class="byui-nav-item byui-nav-itemed">
            <a href="javascript:;">内置模块</a>
            <dl class="byui-nav-child">
              <dd class="byui-this"><a href="byscroll.html">滚动</a></dd>
              <dd><a href="storage.html">存储</a></dd>
            </dl>
          </li>
        </dd>
      </div>
    </div>
    <div class="byui-body">
      <!-- 内容主体区域 -->
      <div style="padding: 15px;">
        <h1 class="site-h1">滚动 - byscroll</h1>
        <blockquote class="byui-elem-quote">
          下拉刷新，上拉加载，兼容PC端手机端主流浏览器。
        </blockquote>
        <fieldset class="byui-elem-field byui-field-title site-title">
          <legend><a name="compatibility">快速开始</a></legend>
        </fieldset>
        <pre class="layui-code layui-box byui-elem-quote"><ol class="byui-code-ol"><li>byui.use('byscroll', function(){
    var byscroll = byui.byscroll;
    console.log（byscroll）
      });</li>
      <li><code class="nav-code">&lt;div id="byscroll" class="byscroll"&gt; <span class="gray">//id可以改,而"byscroll"的class不能删</span>
  &lt;div&gt; <span class="gray">//这个div不能删,否则上拉加载的布局会错位.(可以改成ul或者其他容器标签)</span>
    <span class="gray"> //内容...</span>
  &lt;/div&gt;
&lt;/div&gt;</code></li></ol></pre>
        <pre class="layui-code layui-box byui-elem-quote"><p class="nav-li">固定byscroll的div高度</p><code class="nav-code">
          .byscroll{
            position: fixed;
            top: 44px;
            bottom: 0;
            height: auto; <span class="gray">/*如设置bottom:50px,则需height:auto才能生效*/</span>
          }</code></pre>
        <pre class="layui-code layui-box byui-elem-quote"><p class="nav-li">创建byscroll对象 :</p><code class="nav-code">
              var byscroll = new Byscroll("byscroll", {
                <span class="gray">//如果您的下拉刷新是重置列表数据,那么down完全可以不用配置</span>
           down: {
             callback: downCallback <span class="gray">//下拉刷新的回调</span>
           },
           up: {
             callback: upCallback, <span class="gray">//上拉加载的回调</span>
             <span class="gray">//以下是一些常用的配置,也可不写.</span>
             <span class="gray">page: {</span>
               <span class="gray">num: 0, //当前页 默认0,回调之前会加1; 即callback(page)会从1开始</span>
               <span class="gray">size: 10 //每页数据条数,默认10</span>
             <span class="gray">},</span>
             <span class="gray" style="display: inline-block;margin-bottom: 6px;">htmlNodata: '&lt;p class="upwarp-nodata"&gt;-- END --&lt;/p&gt;',</span>
             <span class="gray">noMoreSize: 5, //如果列表已无数据,可设置列表的总数量要大于5才显示无更多数据;</span>
             <span class="gray">toTop: {</span>
               <span class="gray">//回到顶部按钮</span>
               <span class="gray">src: "", //图片路径,默认null,支持网络图</span>
               <span class="gray">offset: 1000 //列表滚动1000px才显示回到顶部按钮</span>	
             <span class="gray">},</span>
             <span class="gray">empty: {</span>
               <span class="gray">//列表第一页无任何数据时,显示的空提示布局; 需配置warpId才显示</span>
               <span class="gray">warpId:	"xxid",</span>
               <span class="gray">icon: "../img/byscroll-empty.png", //图标,默认null,支持网络图</span>
               <span class="gray">tip: "暂无相关数据~" //提示</span>
             <span class="gray">},</span>
             <span class="gray">lazyLoad: {</span>
                     <span class="gray">use: true // 是否开启懒加载,默认false</span>
                     <span class="gray">attr: 'imgurl' // 标签中网络图的属性名 : &lt;img imgurl='网络图  src='占位图''/&gt;</span>
                   <span class="gray">}</span>
           }
         });</code></pre>
        <pre class="layui-code layui-box byui-elem-quote"><p>回调处理</p><code class="nav-code">
              <span class="gray">//下拉刷新的回调</span>
              function downCallback() {
                <span class="darkgray">$.ajax({</span>
                  <span class="darkgray">url: 'xxxxxx',</span>
                  <span class="darkgray">success: function(data) {</span>
                    <span class="gray">//联网成功的回调,隐藏下拉刷新的状态;</span>
                    <a href="#methods" class="blue">byscroll.endSuccess();</a> <span class="gray">//无参. </span><span class="blue">注意结束下拉刷新是无参的</span>
                    <span class="gray">//设置数据</span>
                    <span class="gray">//setXxxx(data);//自行实现 TODO</span>
                  <span class="darkgray">},</span>
                  <span class="darkgray">error: function(data) {</span>
                    <span class="gray">//联网失败的回调,隐藏下拉刷新的状态</span>
                    <a href="#methods" class="blue">byscroll.endErr();</a>
                  <span id="tagUpCallback" class="darkgray">}</span>
                <span class="darkgray">});</span>
              }
              <span class="gray">//上拉加载的回调 page = {num:1, size:10}; num:当前页 默认从1开始, size:每页数据条数,默认10</span>
              function upCallback(<a href="#tagPage" class="blue">page</a>) {
                var pageNum = page.num; <span class="gray">// 页码, 默认从1开始</span>
                var pageSize = page.size; <span class="gray">// 页长, 默认每页10条</span>
                <span class="darkgray">$.ajax({</span>
                  <span class="darkgray">url: 'xxxxxx?num=' + <span class="green">pageNum</span> + "&amp;size=" + <span class="green">pageSize</span>,</span>
                  <span class="darkgray">success: function(data) {</span>
                    var curPageData = data.xxx; // 接口返回的当前页数据列表
                    var totalPage = data.xxx; // 接口返回的总页数 (比如列表有26个数据,每页10条,共3页; 则totalPage值为3)
                    var totalSize = data.xxx; // 接口返回的总数据量(比如列表有26个数据,每页10条,共3页; 则totalSize值为26)
                    var hasNext = data.xxx; // 接口返回的是否有下一页 (true/false)
                    
                    <span class="gray">//联网成功的回调,隐藏下拉刷新和上拉加载的状态;</span>
                    <span class="gray">//byscroll会根据传的参数,自动判断列表如果无任何数据,则提示空,显示<a href="#tagEmpty" class="blue">empty</a>配置的内容;</span>
                    <span class="gray">//列表如果无下一页数据,则提示无更多数据,(注意<a href="#tagNoMoreSize" class="blue">noMoreSize</a>的配置)</span>
                    
                    <span class="gray">//方法一(推荐): 后台接口有返回列表的总页数 totalPage</span>
                    <span class="gray">//必传参数(当前页的数据个数, 总页数)</span>
                    //byscroll.endByPage(curPageData.length, totalPage);
                        
                    <span class="gray">//方法二(推荐): 后台接口有返回列表的总数据量 totalSize</span>
                    <span class="gray">//必传参数(当前页的数据个数, 总数据量)</span>
                    //byscroll.endBySize(curPageData.length, totalSize);
                        
                    <span class="gray">//方法三(推荐): 您有其他方式知道是否有下一页 hasNext</span>
                    <span class="gray">//必传参数(当前页的数据个数, 是否有下一页true/false)</span>
                    //byscroll.endSuccess(curPageData.length, hasNext);
                        
                    <span class="gray">//方法四 (不推荐),会存在一个小问题:比如列表共有20条数据,每页加载10条,共2页.</span>
                    <span class="gray">//如果只根据当前页的数据个数判断,则需翻到第三页才会知道无更多数据</span>
                    <span class="gray">//如果传了hasNext,则翻到第二页即可显示无更多数据.</span>
                    <span class="gray">//byscroll.endSuccess(curPageData.length);</span>
                    
                    <span class="gray">//结束下拉刷新的 byscroll.endSuccess()无参.</span>
                    <span class="blue">//结束上拉加载 curPageData.length必传的原因:</span>
                      <span class="blue">1.使配置的noMoreSize 和 empty生效</span>
                      <span class="blue">2.判断是否有下一页的首要依据: 当传的值小于page.size时,则一定会认为无更多数据.</span>
                        <span class="blue">比传入的totalPage, totalSize, hasNext具有更高的判断优先级</span>
                      <span class="blue">3.当传的值等于page.size时,才会取totalPage, totalSize, hasNext判断是否有下一页</span>
                        <span class="blue">传totalPage, totalSize, hasNext主要目的是避免方法四描述的小问题</span>
                    
                    <span class="gray">//设置列表数据</span>
                    <span class="gray">//setListData(curPageData);//自行实现 TODO</span>
                  <span class="darkgray">},</span>
                  <span class="darkgray">error: function(e) {</span>
                    <span class="gray">//联网失败的回调,隐藏下拉刷新和上拉加载的状态</span>
                    <a href="#methods" class="blue">byscroll.endErr();</a>
                  <span class="darkgray">}</span>
                <span class="darkgray">});</span>
              }</code>
         </pre>
        <pre class="layui-code layui-box byui-elem-quote">
          <p>图片懒加载</p>
          <code class="nav-code">
              <span class="gray">var byscroll = new Byscroll("byscroll", {</span>
                up: {
                  lazyLoad: {
                          use: true, // 是否开启懒加载,默认false
                          <span class="gray">attr: 'imgurl', // 网络地址的属性名 (图片加载成功会移除该属性): &lt;img imgurl='网络图  src='占位图''/&gt;</span>
                          <span class="gray">showClass: 'byscroll-lazy-in', // 图片加载成功的显示动画: 渐变显示,参见byscroll.css</span>
                          <span class="gray">delay: 500, // 列表滚动的过程中每500ms检查一次图片是否在可视区域,如果在可视区域则加载图片</span>
                          <span class="gray">offset: 200 // 超出可视区域200px的图片仍可触发懒加载,目的是提前加载部分图片</span>
                      }
                }<span class="gray">})</span></code></pre>
        <pre
          class="layui-code layui-box"><a href="up-down.html" style="color:blue">demo页面展示:up-down.html</a></pre>
        <pre class="layui-code layui-box byui-elem-quote">
              <table class="nav-table" cellspacing="0">
                  <tbody><tr><td class="white" colspan="3">var byscroll = new Byscroll ( id或dom对象 , { <a href="#options">down</a> : { 下拉刷新的配置参数 } , <a href="#tagUp">up</a> : { 上拉加载的配置参数 } } ) ;</td></tr>
                  <tr><td class="white" colspan="3"><b><a href="#options">down</a> 下拉刷新的配置参数</b></td></tr>
                  <tr id="tagAuto">
                    <td class="white">参数名</td>
                    <td>默认值</td>
                    <td>说明</td>
                  </tr>
                  <tr>
                    <td>use</td>
                    <td>true</td>
                    <td>是否启用下拉刷新<br>如果配置false,则不会初始化下拉刷新的布局</td>
                  </tr>
                  <tr>
                    <td>auto</td>
                    <td>true</td>
                    <td>是否在初始化完毕之后自动执行一次下拉刷新的回调 <a href="#tagCallback">callback</a></td>
                  </tr>
                  <tr>
                    <td>autoShowLoading</td>
                    <td>false</td>
                    <td>如果设置<a href="#tagAuto">auto</a>=true ( 在初始化完毕之后自动执行下拉刷新的回调 ) ,<br>那么是否显示下拉刷新的进度<br>需配置down的callback才生效</td>
                  </tr>
                  <tr id="tagOffset">
                    <td>isLock</td>
                    <td>false</td>
                    <td>是否锁定下拉刷新<br>如果配置true,则会锁定不可下拉,可通过调用byscroll.lockDownScroll(false)解锁</td>
                  </tr>
                  <tr>
                    <td>isBoth</td>
                    <td>false</td>
                    <td>下拉刷新时,如果滑动到列表底部是否可以同时触发上拉加载</td>
                  </tr>
                  <tr>
                    <td>offset</td>
                    <td>80</td>
                    <td>在列表顶部,下拉大于80px,松手即可触发下拉刷新的回调</td>
                  </tr>
                  <tr>
                    <td>inOffsetRate</td>
                    <td>1</td>
                    <td>在列表顶部,下拉的距离小于offset时,改变下拉区域高度比例;值小于1且越接近0,高度变化越小,表现为越往下越难拉</td>
                  </tr>
                  <tr>
                    <td>outOffsetRate</td>
                    <td>0.2</td>
                    <td>在列表顶部,下拉的距离大于offset时,改变下拉区域高度比例;<br>值越接近0,高度变化越小,表现为越往下越难拉</td>
                  </tr>
                  <tr>
                    <td>bottomOffset</td>
                    <td>20</td>
                    <td>当手指touchmove位置在距离body底部20px范围内的时候结束上拉刷新,避免Webview嵌套导致touchend事件不执行</td>
                  </tr>
                  <tr>
                    <td>minAngle</td>
                    <td>45</td>
                    <td>触发下拉最少要偏移的角度(滑动的轨迹与水平线的锐角值),取值区间 [0,90];默认45度,即向下滑动的角度大于45度(方位角为45°~145°及225°~315°)则触发下拉;而小于45度,将不触发下拉,避免与左右滑动的轮播等组件冲突;<br>注意:没有必要配置超出[0,90]区间的值,否则角度限制无效; 因为假设配置60, 生效的方位角就已经是60°到120° 和 240°到300°的范围了;</td>
                  </tr>
                  <tr>
                    <td>hardwareClass</td>
                    <td>"byscroll-hardware"</td>
                    <td>硬件加速样式,解决iOS下拉因隐藏进度条而闪屏的问题</td>
                  </tr>
                  <tr>
                    <td>warpClass</td>
                    <td>"byscroll-downwarp"</td>
                    <td>下拉刷新的布局容器样式</td>
                  </tr>
                  <tr>
                    <td>mustToTop</td>
                    <td>false</td>
                    <td>是否滚动条必须在顶部,才可以下拉刷新.默认false.<br> 当您发现下拉刷新会闪白屏时,设置true即可修复</td>
                  </tr>
                  <tr>
                    <td>warpId</td>
                    <td>null</td>
                    <td>可配置下拉刷新的布局添加到指定id的div</td>
                  </tr>
                  <tr>
                    <td>resetClass</td>
                    <td>"byscroll-downwarp-reset"</td>
                    <td>下拉刷新高度重置的动画</td>
                  </tr>
                  <tr>
                    <td>textInOffset</td>
                    <td>'下拉刷新'</td>
                    <td>下拉的距离在offset范围内的提示文本</td>
                  </tr>
                    <tr>
                    <td>textOutOffset</td>
                    <td>'释放更新'</td>
                    <td>下拉的距离大于offset范围的提示文本</td>
                  </tr>
                    <tr>
                    <td>textLoading</td>
                    <td>'加载中 ...'</td>
                    <td>加载中的提示文本</td>
                  </tr>
                  <tr id="tagInOffset">
                    <td>htmlContent</td>
                    <td>'&lt;p class="downwarp-progress"&gt;&lt;/p&gt;<br>&lt;p class="downwarp-tip"&gt;&lt;/p&gt;'</td>
                    <td>下拉刷新的布局内容</td>
                  </tr>
                  <tr>
                    <td>inited</td>
                    <td>function ( byscroll, downwarp ) { ... }</td>
                    <td>下拉刷新初始化完毕的回调 (byscroll实例对象,下拉刷新容器dom对象)</td>
                  </tr>
                  <tr>
                    <td>inOffset</td>
                    <td>function ( byscroll ) { ... }</td>
                    <td>下拉的距离进入<a href="#tagOffset">offset</a>范围内那一刻的回调 (byscroll实例对象)</td>
                  </tr>
                  <tr>
                    <td>outOffset</td>
                    <td>function ( byscroll ) { ... }</td>
                    <td>下拉的距离大于<a href="#tagOffset">offset</a>那一刻的回调 (byscroll实例对象)</td>
                  </tr>
                  <tr id="tagBeforeLoading">
                    <td>onMoving</td>
                    <td>function ( byscroll, rate, downHight ) { ... }</td>
                    <td class="left">下拉过程中的回调,滑动过程一直在执行;<br>rate : 拉区域当前高度与指定距离的比值 ( <a href="#tagInOffset">inOffset</a>: rate&lt;1; outOffset: rate&gt;=1 )<br>downHight : 当前下拉区域的高度</td>
                  </tr>
                  <tr id="tagShowLoad">
                    <td>beforeLoading</td>
                    <td class="left">function ( byscroll , downwarp ) { <br>&nbsp; &nbsp; return false; <br>}</td>
                    <td>准备触发下拉刷新的回调; 如果return true,将不触发<a href="#tagShowLoad">showLoading</a>和<a href="#tagCallback">callback</a> <br>常用来完全自定义下拉刷新</td>
                  </tr>
                  <tr>
                    <td>showLoading</td>
                    <td>function ( byscroll ) { ... }</td>
                    <td>显示下拉刷新进度的回调</td>
                  </tr>
                  <tr id="tagCallback">
                    <td>afterLoading</td>
                    <td>function(byscroll) { return 0 }</td>
                    <td>结束加载中,准备隐藏下拉的回调 <br>返回结束下拉的延时执行时间,默认0ms<br>常用于结束下拉之前再显示另外一小段动画,才去隐藏下拉刷新的场景<br></td>
                  </tr>
                  <tr id="tagUp">
                    <td>callback</td>
                    <td class="left">function ( byscroll ) { <br>&nbsp; &nbsp; byscroll.resetUpScroll(); <br>}</td>
                    <td>下拉刷新的回调; 默认重置上拉加载列表为第一页</td>
                  </tr>
                  
                  <tr><td class="white" colspan="3"><b><span class="green">up</span> 上拉加载的配置参数</b></td></tr>
                  <tr>
                    <td class="white">参数名</td>
                    <td>默认值</td>
                    <td>说明</td>
                  </tr>
                  <tr>
                    <td>use</td>
                    <td>true</td>
                    <td>是否启用上拉加载<br>如果配置false,则不会初始化上拉加载的布局</td>
                  </tr>
                  <tr>
                    <td>auto</td>
                    <td></td>
                    <td>是否在初始化完毕之后自动执行一次上拉加载的回调</td>
                  </tr>
                  <tr>
                    <td>isLock</td>
                    <td>false</td>
                    <td>是否锁定上拉加载<br>如果配置true,则会锁定不可上拉,可通过调用byscroll.lockUpScroll(false)解锁</td>
                  </tr>
                  <tr>
                    <td>isBoth</td>
                    <td><span id="tagNoMoreSize"></span>false</td>
                    <td>上拉加载时,如果滑动到列表顶部是否可以同时触发下拉刷新</td>
                  </tr>
                  <tr>
                    <td>isBounce</td>
                    <td>true</td>
                    <td>是否允许ios的bounce回弹;默认true,允许回弹</td>
                  </tr>
                  <tr>
                    <td>offset</td>
                    <td>100</td>
                    <td>列表滚动到距离底部小于100px,即可触发上拉加载的回调</td>
                  </tr>
                  <tr>
                    <td>noMoreSize</td>
                    <td>5</td>
                    <td>如果列表已无数据,可设置列表的总数量要大于5条才显示无更多数据;</td>
                  </tr>
                  <tr>
                    <td>toTop</td>
                    <td class="left">{ <br>&nbsp; warpId : null , <br>&nbsp; src : null , <br>&nbsp; html: null , <br>&nbsp; offset : 1000 , <br>&nbsp; warpClass : "byscroll-totop" , <br>&nbsp; showClass : "byscroll-fade-in" , <br>&nbsp; hideClass : "byscroll-fade-out" , <br>&nbsp; duration : 300 , <br>&nbsp; supportTap : false <br>&nbsp; btnClick : null <br>}</td>
                    <td class="left">回到顶部按钮的配置: <br>warpId: 父布局的id; 默认添加在body中<br>src : 图片路径,必须配置src才会显示回到顶部按钮,不配置不显示 <br>html: 标签内容,默认null; 如果同时设置了src,则优先取src<br>offset : 列表滚动1000px显示回到顶部按钮 <br>warpClass : 按钮样式<br>showClass : 显示样式<br> hideClass : 隐藏样式<br>duration : 回到顶部的动画时长, 默认300ms<br>supportTap: 如果您的运行环境支持tap,则可配置true,可减少点击延时,快速响应事件;默认false,通过onclick添加点击事件;(注:微信和PC无法响应tap事件)<br>btnClick: 点击按钮的回调; 提示:如果在回调里return true,将不执行回到顶部的操作
                    </td>
                  </tr>
                  <tr>
                    <td>loadFull</td>
                    <td class="left">{ <br><span id="tagEmpty">&nbsp; use : false , <br></span>&nbsp; delay : 500 <br>}</td>
                    <td class="left"></br> use : 列表数据过少,不足以滑动触发上拉加载,是否自动加载下一页,直到满屏或无数据; 默认false,因为可调大<a href="#tagPage">page.size</a>使数据满屏.<br></br> delay : 延时执行的毫秒数; 延时是为了保证列表数据或占位的图片都已初始化完成,且下拉刷新上拉加载中区域动画已执行完毕;
                    </td>
                  </tr>
                  <tr>
                    <td>empty</td>
                    <td class="left">{ <br>&nbsp; warpId : null , <br>&nbsp; icon : null , <br>&nbsp; tip : "暂无相关数据~" , <br><span id="tagClearId">&nbsp; btntext : "" , <br></span>	&nbsp; btnClick : null <br>&nbsp; supportTap : false <br>}</td>
                    <td class="left">列表第一页无任何数据时,显示的空布局 (需配置warpId才生效) <br>warpId : 父布局的id<br>icon : 空布局的图标路径 <br>tip : 提示文本 <br>btntext : 按钮文本 <br>btnClick : 点击按钮的回调 <br>supportTap: 如果您的运行环境支持tap,则可配置true,可减少点击延时,快速响应事件;默认false,通过onclick添加点击事件;(注:微信和PC无法响应tap事件)
                    </td>
                  </tr>
                  <tr id="tagClearEmptyId">
                    <td>clearId</td>
                    <td>null</td>
                    <td>加载第一页时需清空数据的列表id<br>如果此项有值,将不使用<a href="#tagClearEmptyId">clearEmptyId</a>的值<br>在vue中使用,不能配置此项</td>
                  </tr>
                  <tr>
                    <td>clearEmptyId</td>
                    <td>null</td>
                    <td>相当于同时设置了<a href="#tagClearId">clearId</a>和<a href="#tagEmpty">empty.warpId</a> 简化写法;<br>在vue中使用,不能配置此项</td>
                  </tr>
                  <tr>
                    <td>hardwareClass</td>
                    <td>"byscroll-hardware"</td>
                    <td>硬件加速样式,使动画更流畅</td>
                  </tr>
                  <tr>
                    <td>warpId</td>
                    <td>null</td>
                    <td>可配置上拉加载的布局添加到指定id的div</td>
                  </tr>
                  <tr>
                    <td>warpClass</td>
                    <td>"byscroll-upwarp"</td>
                    <td>上拉加载的布局容器样式</td>
                  </tr>
                  <tr id="tagHtmlNodata">
                    <td>htmlLoading</td>
                    <td>'&lt;p class="upwarp-progress byscroll-rotate"&gt;&lt;/p&gt;&lt;p class="upwarp-tip"&gt;加载中..&lt;/p&gt;'</td>
                    <td>上拉加载中的布局</td>
                  </tr>
                  <tr>
                    <td>htmlNodata</td>
                    <td>'&lt;p class="upwarp-nodata"&gt;<br>-- END --<br>&lt;/p&gt;'</td>
                    <td>无数据的布局</td>
                  </tr>
                  <tr>
                    <td>inited</td>
                    <td>function ( byscroll , upwarp ) { }</td>
                    <td>初始化完毕的回调<br>回调(byscroll实例, upwarp上拉加载的布局Dom对象)</td>
                  </tr>
                  <tr>
                    <td>showLoading</td>
                    <td>function ( byscroll , upwarp ) { ... }</td>
                    <td>显示上拉加载中的回调<br>回调(byscroll实例, upwarp上拉加载的布局Dom对象)</td>
                  </tr>
                  <tr>
                    <td>showNoMore</td>
                    <td>function ( byscroll , upwarp ) { ... }</td>
                    <td>显示无更多数据的回调<br>回调(byscroll实例, upwarp上拉加载的布局Dom对象)</td>
                  </tr>
                  <tr>
                    <td>onScroll</td>
                    <td>null</td>
                    <td>列表滑动监听, 默认null<br>例 onScroll : function(byscroll, y, isUp){ ... };<br>y为列表当前滚动条的位置;<br>isUp=true向上滑,isUp=false向下滑)</td>
                  </tr>
                  <tr id="tagPage">
                    <td>callback</td></br><td>function ( page, byscroll ) { }</td>
                    <td>上拉加载的回调; 回调 ( <a href="#tagPage">page</a>对象, byscroll实例 )</td>
                  </tr>
                  <tr>
                    <td>page</td>
                    <td class="left">{<br>&nbsp; num : 0 , <br>&nbsp; size : 10 , <br>&nbsp; time : null <br>}</td>
                    <td class="left">num : 当前页码,默认0,回调之前加1,即<a href="#tagCallback">callback</a>(page)从1开始;<br>size : 每页数据的数量; <br>time : 加载第一页数据服务器返回的时间 (可空); 防止用户翻页时,后台新增了数据从而导致下一页数据重复;</td>
                  </tr>
                  <tr>
                    <td>scrollbar</td>
                    <td class="left">{<br>&nbsp; use : ... , <br>&nbsp; barClass : "byscroll-bar" <br>}</td>
                    <td class="left">use : 是否开启自定义滚动条;<br>PC端默认true开启自定义滚动条; 移动端默认false不使用 <br><br>barClass : 自定义滚动条的样式;</td>
                  </tr>
                  <tr>
                    <td>lazyLoad</td>
                    <td class="left">{<br>&nbsp; use: false,<br>&nbsp; attr: 'imgurl',<br>&nbsp; showClass: 'byscroll-lazy-in',<br>&nbsp; delay: 500,<br>&nbsp; offset: 200<br>}</td>
                    <td class="left">use: 是否开启懒加载,默认false<br>attr: 标签中网络图片地址的属性名,默认"imgurl"<br> showClass: 显示样式:渐变显示,参见byscroll.css<br>delay: 列表滚动的过程中检查一次图片是否在可视区域的时间间隔,默认500 (单位ms)<br>offset: 超出可视区域多少px的图片仍可触发懒加载 默认200
                    </td>
                  </tr>
                </tbody></table>
          </pre>
        <pre class="layui-code layui-box byui-elem-quote"><p id="methods" class="nav-title">常用方法 :</p>
            <table class="nav-table" cellspacing="0">
                <tbody><tr>
                  <td class="white">方法名</td>
                  <td>说明</td>
                </tr>
                <tr>
                  <td class="left">byscroll.endByPage(dataSize, totalPage, systime)</td>
                  <td class="left">隐藏下拉刷新和上拉加载的状态, 在联网获取数据成功后调用<br>dataSize : 当前页获取的数据总数(注意是当前页)<br>totalPage : 列表的总页数<br>systime : 加载第一页数据的服务器时间 (可空);</a>
                  </td>
                </tr>
                <tr>
                  <td class="left">byscroll.endBySize(dataSize, totalSize, systime)</td>
                  <td class="left">隐藏下拉刷新和上拉加载的状态, 在联网获取数据成功后调用<br>dataSize : 当前页获取的数据总数(注意是当前页)<br>totalSize : 列表的总数据量<br>systime : 加载第一页数据的服务器时间 (可空);
                  </td>
                </tr>
                <tr>
                  <td class="left">byscroll.endSuccess(dataSize, hasNext, systime)</td>
                  <td class="left">隐藏下拉刷新和上拉加载的状态, 在联网获取数据成功后调用<br>dataSize : 当前页获取的数据量(注意是当前页)<br>hasNext : 是否有下一页数据true/false<br>systime : 加载第一页数据的服务器时间 (可空);
                  </td>
                </tr>
                <tr>
                  <td class="left">byscroll.endErr();</td>
                  <td class="left">隐藏下拉刷新和上拉加载的状态, 在联网获取数据失败后调用;<br>byscroll内部会自动恢复原来的页码,时间等变量;</td>
                </tr>
                <tr>
                  <td class="left">byscroll.resetUpScroll( isShowLoading );</td>
                  <td class="left">重置列表为第一页 (常用于列表筛选条件变化或切换菜单时重新刷新列表数据)<br>内部实现: 把page.num=1,再主动触发up.callback<br>isShowLoading 是否显示进度布局; <br>1.默认null,不传参,则显示上拉加载的进度布局 <br>2.传参true, 则显示下拉刷新的进度布局<br>3.传参false,则不显示上拉和下拉的进度 (常用于静默更新列表数据)</td>
                </tr>
                <tr>
                  <td class="left">byscroll.triggerDownScroll();</td>
                  <td>主动触发下拉刷新</td>
                </tr>
                <tr>
                  <td class="left">byscroll.triggerUpScroll();</td>
                  <td>主动触发上拉加载</td>
                </tr>
                <tr>
                  <td class="left">byscroll.setPageNum(num)</td>
                  <td>设置当前page.num的值</td>
                </tr>
                <tr>
                  <td class="left">byscroll.setPageSize(size)</td>
                  <td>设置当前page.size的值</td>
                </tr>
                <tr>
                  <td class="left">byscroll.scrollTo( y, t );</td>
                  <td class="left">滚动列表到指定位置<br>y=0,则回到列表顶部; 如需滚动到列表底部,可设置y很大的值,比如y=99999<br>t时长,单位ms,默认300; 如果不需要动画缓冲效果,则传0 (需更新至1.2.3版本)</td>
                </tr>
                <tr>
                  <td class="left">byscroll.optDown;</td>
                  <td>获取下拉刷新的配置 </td>
                </tr>
                <tr>
                  <td class="left">byscroll.optUp;</td>
                  <td>获取上拉加载的配置 </td>
                </tr>
                <tr>
                  <td class="left">byscroll.lockDownScroll( isLock );</td>
                  <td>锁定下拉刷新  ( isLock=ture,null 锁定 ; isLock=false 解锁 )</td>
                </tr>
                <tr>
                  <td class="left">byscroll.lockUpScroll( isLock );</td>
                  <td>锁定上拉加载 ( isLock=ture,null 锁定 ; isLock=false 解锁 )</td>
                </tr>
                <tr>
                  <td class="left">byscroll.os<br></td>
                  <td>byscroll.os.ios 为true, 则是ios设备;<br>byscroll.os.android 为true, 则是android设备;<br>byscroll.os.pc 为true, 则是PC端;
                  </td>
                </tr>
                <tr>
                  <td class="left">byscroll.setBounce(boolean)<br></td>
                  <td><b>byscroll.setBounce(true)</b> 允许bounce;<br><b>byscroll.setBounce(false)</b> 禁止bounce
                  </td>
                </tr>
                <tr>
                  <td class="left">byscroll.lazyLoad(delay)<br></td>
                  <td>主动触发懒加载: 自动加载可视区域的图片.<br>delay:延时加载图片的时间,默认500ms.目的是确保dom元素已渲染完成.
                  </td>
                </tr>
              </tbody></table>
          </pre>
        <pre class="layui-code layui-box byui-elem-quote"><p id="others" class="nav-title">其他方法 :</p>
            <table class="nav-table" cellspacing="0">
                <tbody><tr><td colspan="2" class="white">以下方法不常用,您可灵活运用于更复杂的场景</td></tr>
           <tr>
             <td class="white">方法名</td>
             <td>说明</td>
           </tr>
           <tr>
             <td class="left">byscroll.showDownScroll();</td>
             <td>显示下拉刷新的进度布局<br>byscroll.triggerDownScroll() 和 byscroll.resetUpScroll() 内部有调用</td>
           </tr>
           <tr>
             <td class="left">byscroll.endDownScroll();</td>
             <td>隐藏下拉刷新的进度布局<br>byscroll.endSuccess() 和 byscroll.endErr() 内部有调用</td>
           </tr>
           <tr>
             <td class="left">byscroll.endUpScroll(isShowNoMore)</td>
             <td>结束上拉加载的状态<br>isShowNoMore=true, 显示无更多数据;<br>isShowNoMore=false, 隐藏上拉加载;<br>isShowNoMore=null, 保持当前状态</td>
           </tr>
           <tr>
             <td class="left">byscroll.showUpScroll();</td>
             <td>显示上拉加载的进度布局<br>byscroll.triggerDownScroll() 和 byscroll.resetUpScroll() 内部有调用</td>
           </tr>
           <tr>
             <td class="left">byscroll.showNoMore();</td>
             <td>显示上拉无更多数据的布局<br>byscroll.endUpScroll() 内部有调用</td>
           </tr>
           <tr>
             <td class="left">byscroll.hideUpScroll(displayAble);</td>
             <td>隐藏上拉加载的布局<br>byscroll.endUpScroll() 内部有调用<br>displayAble: 是否通过display:none隐藏<br>默认false通过visibility:hidden的方式隐藏
             </td>
           </tr>
           <tr>
             <td class="left">byscroll.clearDataList();</td>
             <td>清空上拉加载的数据列表<br>byscroll.resetUpScroll() 和 byscroll.endSuccess() 内部有调用</td>
           </tr>
           <tr>
             <td class="left">byscroll.showEmpty();</td>
             <td>显示无任何数据的空布局<br>byscroll.endSuccess() 内部有调用</td>
           </tr>
           <tr>
             <td class="left">byscroll.removeEmpty();</td>
             <td>移除无任何数据的空布局<br>byscroll.endSuccess() 内部有调用</td>
           </tr>
           <tr>
             <td class="left">byscroll.showTopBtn(time);</td>
             <td>显示回到顶部的按钮<br>time: 显示的动画时长,默认0.5秒 (1.3.5版本新增参数)</td>
           </tr>
           <tr>
             <td class="left">byscroll.hideTopBtn(time);</td>
             <td>隐藏回到顶部的按钮 <br>time: 隐藏的动画时长,默认0.5秒 (1.3.5版本新增参数)</td>
           </tr>
           <tr>
             <td class="left">byscroll.setTopBtnFadeDuration(time)</td>
             <td>设置回到顶部按钮的显示和隐藏的动画时长 <br>time: 显示隐藏动画时长,默认0.5秒</td>
           </tr>
           <tr>
             <td class="left">byscroll.getScrollTop();</td>
             <td>获取滚动条的位置y; 也可以在up配置onScroll监听滚动条的位置</td>
           </tr>
           <tr>
             <td class="left">byscroll.getBodyHeight();</td>
             <td>获取body的高度 </td>
           </tr>
           <tr>
             <td class="left">byscroll.getClientHeight();</td>
             <td>获取滚动容器的高度 </td>
           </tr>
           <tr>
             <td class="left">byscroll.getScrollHeight();</td>
             <td>获取滚动内容的高度 </td>
           </tr>
           <tr>
             <td class="left">byscroll.getToBottom()</td>
             <td>获取当前滚动条到底部的距离 </td>
           </tr>
           <tr>
             <td class="left">byscroll.getStep(star, end, callback, t, rate)</td>
             <td align="left">star : 开始值; <br>end : 结束值; <br>callback(step,timer) :  回调 function(step,timer), <br>t : 计步时长; 传0则直接回调end值; 不传则默认300ms ; <br>rate : 周期; 不传则默认30ms计步一次 ; <br>此方法相当于默认在300ms内,每30ms返回star到end之间的阶梯值step; 可用于模拟帧动画 <br>比如byscroll的回到顶部缓冲动画,轮播导航案例的顶部菜单滚动都是通过getStep实现<br>(注: 您可根据实际情况在 callback 通过 window.clearInterval(timer) 提前结束计步器)
              </td>
           </tr>
           <tr>
             <td class="left">byscroll.version</td>
             <td>byscroll的版本号</td>
           </tr>
           <tr>
             <td class="left">byscroll.destroy();</td>
             <td>销毁byscroll</td>
           </tr>
         </tbody></table>
          </pre>
      </div>
    </div>
  </div>
  <script src="../dist/byui.js"></script>
  <script>
    //JavaScript代码区域
    byui.use("element", function () {
      var element = byui.element;
    });
  </script>
</body>

</html>